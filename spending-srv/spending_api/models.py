import string, random, inspect

from . import financeparser

from django.utils import timezone
from django.db import models


def id_generator(size=15, chars=string.ascii_uppercase + string.digits):
    return ''.join(random.choice(chars) for _ in range(size))


class Workspace(models.Model):
    """
    A key for the user to identity the workspace... lazy security :), someday these will have owners
    """
    public_key = models.CharField(max_length=30, default=id_generator)
    """
    TODO: future use
    """
    owner = models.CharField(max_length=30, null=True)
    """
    When this was created
    """
    create_date = models.DateTimeField(default=timezone.now)

    def intake_file(self, original_name):
        """
        Take in a file joining it to the current workspace to be parsed
        :param original_name: The orriginal name of the file for classification purposes
        :return:
        """
        return self.workfile_set.create(original_name=original_name)


class WorkFile(models.Model):
    """
    The classifier that was matched
    """
    type = models.CharField(max_length=30)
    """
    Part of the renamed name
    """
    public_key = models.CharField(max_length=30, default=id_generator)
    """
    The orriginal file - all files are renamed for security reasons
    """
    original_name = models.CharField(max_length=255, null=True)
    """
    The owning workspace
    """
    workspace = models.ForeignKey(Workspace, on_delete=models.CASCADE)
    """
    When this was created
    """
    create_date = models.DateField(default=timezone.now)

    def get_file_name(self):
        return "{0}-{1}".format(self.id, self.public_key)

    def classify_workfile(self):
        """
        Match the current file to a reader
        :return:
        """
        for name, obj in inspect.getmembers(financeparser):
            accept_fn = getattr(obj, "accept", None)

            if inspect.isclass(obj) and accept_fn is not None:
                # fabricate the class and try an accept
                reader = obj(self)

                if reader.accept():
                    # if a match then return it
                    return reader

        return None

    def parse_to_journal(self, fso):
        """
        Parse the file and read into a standard dictionary object (name, amount, date)
        :param fso: An object that implements open for file reading
        :return: True if the read was successful
        """
        reader = self.classify_workfile()

        if reader is None:
            return False

        self.type = str(reader)
        result_set = reader.read(fso)

        # after all the records have been read in, we create django entity records w. kwargs transform
        for record in result_set:
            if len(record.get("name", "")) > 0 and len(record.get("amount", "")) > 0:
                r = self.workspace.journal_set.create(**record)
                r.source = self.public_key
                r.save()

        return True


class Journal(models.Model):
    """
    The journal transaction text read in from file
    """
    name = models.CharField(max_length=300)
    """
    The journal amount read in from file
    """
    amount = models.DecimalField(max_digits=15, decimal_places=2)
    """
    The date read in from file
    """
    transaction_date = models.DateField()
    """
    The category that this record has been classified to
    """
    path_classification = models.CharField(max_length=200)
    """
    The rule this category was assigned to (public key) or None or "manual"
    manual assignments don't get overwritten by rules unless explicity set by the UI.
    """
    applied_rule = models.CharField(max_length=200, null=True)
    """
    The file this came from
    """
    source = models.CharField(max_length=30, null=True, default=None)
    """
    The workspace that owns this transaction
    """
    workspace = models.ForeignKey(Workspace, on_delete=models.CASCADE)
    """
    When the record was created
    """
    create_date = models.DateField(default=timezone.now)


class Rule(models.Model):
    """
    The instring expression for matching against the name of a journal record
    """
    expression = models.CharField(max_length=200)
    """
    The category we assign if the rule matches a journal entry
    """
    path = models.CharField(max_length=200)
    """
    A key generated by the client that gets assigned to applied_rule
    """
    public_key = models.CharField(max_length=200, null=True)
    """
    The amount minimum or null, 0 counts as null
    """
    amount_from = models.DecimalField(max_digits=15, decimal_places=2, null=True, default=None)
    """
    The amount maximum or null, 0 counts as null
    """
    amount_to = models.DecimalField(max_digits=15, decimal_places=2, null=True, default=None)
    """
    The owning workspace
    """
    workspace = models.ForeignKey(Workspace, on_delete=models.CASCADE)
    """
    When the record was created
    """
    create_date = models.DateField(default=timezone.now)

